---
title: "STAT 537 Project"
output: pdf_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

```{r, message=FALSE}
library(agricolae)
library(car)
library(factoextra)
library(forcats)
library(ggplot2)
library(regclass)
set.seed(537)
```

```{r}
## Data cleanup
diab <- read.csv("diabetes_prediction_dataset.csv")
diab <- na.omit(diab)
diab <- unique(diab)

# Factorize categorical covariates
diab$gender <- as.factor(diab$gender)
diab$hypertension <- as.factor(diab$hypertension)
diab$heart_disease <- as.factor(diab$heart_disease)
diab$smoking_history <- as.factor(diab$smoking_history)
diab$blood_glucose_level <- as.numeric(diab$blood_glucose_level)
diab$diabetes <- as.factor(diab$diabetes)

# Remove gender == "Other" and smoking_history == "No Info" 
diab <- diab[-which(diab$gender == "Other"),]
diab$gender <- droplevels(diab$gender)
diab <- diab[-which(diab$smoking_history == "No Info"),]
diab$smoking_history <- droplevels(diab$smoking_history)

# Refactor smoking_history into just Yes/No
diab$smoking_history <- fct_collapse(diab$smoking_history, "0" = c("never"),
                                     "1" = c("current", "ever", "former", "not current"))

summary(diab)
```

```{r}
## PCA to test for possible dimension reduction

diab.pca <- diab[,-9]
for (i in 1:8) {
  diab.pca[,i] <- as.numeric(diab.pca[,i])
}
diab.pca <- scale(diab.pca)
pca <- prcomp(diab.pca)
summary(pca)
fviz_eig(pca, addlabels=TRUE)
# Nah we good
```

```{r}
## 20/80 test/train split; sampled from each diabetes category because data is unbalanced
diab <- diab[order(diab$diabetes, decreasing=TRUE),]
diabetes_count <- length(which(diab$diabetes == 1))
no_diabetes_count <- length(which(diab$diabetes == 0))
diabetes_test <- sample(1:diabetes_count, ceiling(diabetes_count*0.2))
no_diabetes_test <- sample((diabetes_count+1):nrow(diab), ceiling(no_diabetes_count*0.2))
diab_test <- diab[c(diabetes_test, no_diabetes_test),]
diab_train <- diab[-c(diabetes_test, no_diabetes_test),]
```

```{r}
## Try initial logistic model
M0 <- glm(diabetes~., data=diab_train, family=binomial(link="logit"))
summary(M0)
```

```{r}
## Smoking history is concerning; can we get rid of it?
M1 <- glm(diabetes~.-smoking_history, data=diab_train, family=binomial(link="logit"))

anova(M1, M0, test="Chisq")
# Yes

diab_train <- diab_train[,-5]
diab_test <- diab_test[,-5]
```
```{r}
M1 <- glm(diabetes~., data=diab_train, family=binomial(link="logit"))
summary(M1)
```

```{r}
prob <- predict(M1, type="response")
for (i in c(2,5,6,7)) {
  plot(x=diab_train[,i], y=log(prob/(1-prob)), xlab=names(diab_train[i]), ylab="Log OR")
}
# Take log(bmi)?
```

```{r}
diab_train[,5] <- log(diab_train[,5])
names(diab_train)[5] <- "log(bmi)"
diab_test[,5] <- log(diab_test[,5])
names(diab_test)[5] <- "log(bmi)"

M2 <- glm(diabetes~., data=diab_train, family=binomial(link="logit"))
summary(M2)
plot(x=diab_train[,5], y=log(prob/(1-prob)), xlab=names(diab_train[5]), ylab="Log OR")

# A little better
```

```{r}
VIF(M2)
# No multicolinearity
```

\begin{align*}
\log(\frac{\pi_i}{1-\pi_i}) &= \beta_0+\beta_1I(male)+\beta_2x_{age}+\beta_3I(HT)+\beta_4I(HD)+\beta_5\log(x_{BMI})+\beta_6x_{HbA1c}+\beta_7x_{BGL} \\
&= -34.16+0.21I(male)+0.05x_{age}+0.71I(HT)+0.71I(HD)+2.93\log(x_{BMI})+2.29x_{HbA1c}+0.03x_{BGL} \\
\end{align*}

```{r}
# Predict probabilities on the test data for model_3
probabilities <- predict(M2, newdata = diab_train, type = "response")

# Initialize vectors to store metrics
accuracy <- c()
precision <- c()
recall <- c()
thresholds <- seq(0, 1, by = 0.05)

for (threshold in thresholds) {
  # Make predictions based on the threshold
  predicted_outcomes <- ifelse(probabilities > threshold, 1, 0)

  # Calculate TP, FP, FN, TN
  TP <- sum(predicted_outcomes == 1 & diab_train$diabetes == 1)
  FP <- sum(predicted_outcomes == 1 & diab_train$diabetes == 0)
  FN <- sum(predicted_outcomes == 0 & diab_train$diabetes == 1)
  TN <- sum(predicted_outcomes == 0 & diab_train$diabetes == 0)

  # Calculate metrics
  acc <- (TP + TN) / (TP + FP + FN + TN)
  prec <- ifelse(TP + FP == 0, 0, TP / (TP + FP))
  rec <- ifelse(TP + FN == 0, 0, TP / (TP + FN))

  # Store the metrics
  accuracy <- c(accuracy, acc)
  precision <- c(precision, prec)
  recall <- c(recall, rec)
}

# Create a data frame for the results
results_df <- data.frame(Threshold = thresholds, Accuracy = accuracy, Precision = precision, Recall = recall)

# Print the data frame
print(results_df)

# Generate a line graph
plot(results_df$Threshold, results_df$Accuracy, type = "l", col = "green", ylim = range(0, 1),
     xlab = "Threshold", ylab = "Metric Value", main = "Model Metrics by Threshold on Training Data")
lines(results_df$Threshold, results_df$Precision, col = "blue")
lines(results_df$Threshold, results_df$Recall, col = "red")
legend("bottomright", legend = c("Accuracy", "Precision", "Recall"), col = c("green", "blue", "red"), lty = 1)

```

```{r}
# Predict probabilities on the test data for model_3
probabilities <- predict(M2, newdata = diab_train, type = "response")

# Initialize vectors to store FP and FN rates
fp_rates <- c()
fn_rates <- c()
thresholds <- seq(0, 1, by = 0.05)  # Adjust the step size as needed

# Total actual positives and negatives
total_positives <- sum(diab_train$diabetes == 1)
total_negatives <- sum(diab_train$diabetes == 0)

for (threshold in thresholds) {
  # Make predictions based on the threshold
  predicted_outcomes <- ifelse(probabilities > threshold, 1, 0)
  
  # Calculate FP and FN
  fp <- sum(predicted_outcomes == 1 & diab_train$diabetes == 0)
  fn <- sum(predicted_outcomes == 0 & diab_train$diabetes == 1)

  # Calculate and store the rates
  fp_rate <- fp / total_negatives
  fn_rate <- fn / total_positives
  fp_rates <- c(fp_rates, fp_rate)
  fn_rates <- c(fn_rates, fn_rate)
}

# Plotting
plot(thresholds, fp_rates, type = "l", col = "blue", ylim = c(0, max(c(fp_rates, fn_rates))),
     xlab = "Threshold", ylab = "Rate", main = "False Negative and False Positive Trade-off by Threshold on Train Data", 
     xaxt = 'n', yaxt = 'n')
axis(1, at = seq(0, 1, by = 0.05))
axis(2, at = seq(0, max(c(fp_rates, fn_rates)), by = 0.1))
lines(thresholds, fn_rates, type = "l", col = "red")
legend("topright", legend = c("False Positive Rate", "False Negative Rate"), col = c("blue", "red"), lty = 1)

```

```{r}
# Predict probabilities on the test data for model_3
probabilities <- predict(M2, newdata = diab_test, type = "response")

# Initialize vectors to store metrics
accuracy <- c()
precision <- c()
recall <- c()
thresholds <- seq(0, 1, by = 0.05)

for (threshold in thresholds) {
  # Make predictions based on the threshold
  predicted_outcomes <- ifelse(probabilities > threshold, 1, 0)

  # Calculate TP, FP, FN, TN
  TP <- sum(predicted_outcomes == 1 & diab_test$diabetes == 1)
  FP <- sum(predicted_outcomes == 1 & diab_test$diabetes == 0)
  FN <- sum(predicted_outcomes == 0 & diab_test$diabetes == 1)
  TN <- sum(predicted_outcomes == 0 & diab_test$diabetes == 0)

  # Calculate metrics
  acc <- (TP + TN) / (TP + FP + FN + TN)
  prec <- ifelse(TP + FP == 0, 0, TP / (TP + FP))
  rec <- ifelse(TP + FN == 0, 0, TP / (TP + FN))

  # Store the metrics
  accuracy <- c(accuracy, acc)
  precision <- c(precision, prec)
  recall <- c(recall, rec)
}

# Create a data frame for the results
results_df <- data.frame(Threshold = thresholds, Accuracy = accuracy, Precision = precision, Recall = recall)

# Print the data frame
print(results_df)

# Generate a line graph
plot(results_df$Threshold, results_df$Accuracy, type = "l", col = "green", ylim = range(0, 1),
     xlab = "Threshold", ylab = "Metric Value", main = "Model Metrics by Threshold on Test Data")
lines(results_df$Threshold, results_df$Precision, col = "blue")
lines(results_df$Threshold, results_df$Recall, col = "red")
legend("bottomright", legend = c("Accuracy", "Precision", "Recall"), col = c("green", "blue", "red"), lty = 1)

```

```{r}
# Predict probabilities on the test data for model_3
probabilities <- predict(M2, newdata = diab_test, type = "response")

# Initialize vectors to store FP and FN rates
fp_rates <- c()
fn_rates <- c()
thresholds <- seq(0, 1, by = 0.05)  # Adjust the step size as needed

# Total actual positives and negatives
total_positives <- sum(diab_test$diabetes == 1)
total_negatives <- sum(diab_test$diabetes == 0)

for (threshold in thresholds) {
  # Make predictions based on the threshold
  predicted_outcomes <- ifelse(probabilities > threshold, 1, 0)
  
  # Calculate FP and FN
  fp <- sum(predicted_outcomes == 1 & diab_test$diabetes == 0)
  fn <- sum(predicted_outcomes == 0 & diab_test$diabetes == 1)

  # Calculate and store the rates
  fp_rate <- fp / total_negatives
  fn_rate <- fn / total_positives
  fp_rates <- c(fp_rates, fp_rate)
  fn_rates <- c(fn_rates, fn_rate)
}

# Plotting
plot(thresholds, fp_rates, type = "l", col = "blue", ylim = c(0, max(c(fp_rates, fn_rates))),
     xlab = "Threshold", ylab = "Rate", main = "False Negative and False Positive Trade-off by Threshold on Test Data", 
     xaxt = 'n', yaxt = 'n')
axis(1, at = seq(0, 1, by = 0.05))
axis(2, at = seq(0, max(c(fp_rates, fn_rates)), by = 0.1))
lines(thresholds, fn_rates, type = "l", col = "red")
legend("topright", legend = c("False Positive Rate", "False Negative Rate"), col = c("blue", "red"), lty = 1)

```
